Got it ðŸ‘
Here is the **condensed, no-noise instruction checklist** for **implementing auth on the TanStack Start side** when the backend is **Django + DRF + session auth**.

---

## 0ï¸âƒ£ Core rule (donâ€™t break this)

* **TanStack does NOT authenticate**
* **Django owns auth + sessions**
* TanStack only **asks â€œwho is the current user?â€**

---

## 1ï¸âƒ£ One required API on Django

TanStack assumes this exists:

```
GET /api/auth/me/
â†’ 200 { id, email, role }
â†’ 401 if not authenticated
```

Session cookie (`sessionid`) must be sent automatically.

---

## 2ï¸âƒ£ One server function (single source of truth)

```ts
// server/auth.ts
export const getCurrentUserFn = createServerFn({ method: 'GET' })
  .handler(async () => {
    const res = await fetch('http://backend/api/auth/me/', {
      credentials: 'include',
    })

    if (!res.ok) return null
    return res.json()
  })
```

âš ï¸ Never duplicate this logic.

---

## 3ï¸âƒ£ Put user in router context (once)

```ts
// router.ts
const router = createRouter({
  context: {
    user: null as User | null,
    getCurrentUser: getCurrentUserFn,
  },
})
```

---

## 4ï¸âƒ£ `_authed` layout = authentication gate

```ts
// routes/_authed/index.tsx
export const Route = createFileRoute('/_authed')({
  beforeLoad: async ({ context }) => {
    const user = await context.getCurrentUser()

    if (!user) {
      throw redirect({ to: '/login' })
    }

    return { user }
  },
})
```

âœ” Runs on **server**
âœ” Blocks unauthenticated users
âœ” Passes `user` to children

---

## 5ï¸âƒ£ Role protection (authorization)

```ts
// routes/_authed/admin.tsx
export const Route = createFileRoute('/_authed/admin')({
  beforeLoad: ({ context }) => {
    if (context.user.role !== 'admin') {
      throw redirect({ to: '/unauthorized' })
    }
  },
})
```

Frontend check = UX
Backend must still enforce permissions.

---

## 6ï¸âƒ£ Login & logout (thin client calls)

```ts
// login
await fetch('/api/auth/login/', {
  method: 'POST',
  credentials: 'include',
})

// logout
await fetch('/api/auth/logout/', {
  method: 'POST',
  credentials: 'include',
})
```

âœ” No tokens
âœ” No localStorage
âœ” Cookie handles everything

---

## 7ï¸âƒ£ Rendering rules

* `beforeLoad` â‡’ **SSR**
* Server functions â‡’ **SSR**
* No `useEffect` for auth
* No client-only guards

---

## 8ï¸âƒ£ URL rule

* **All backend endpoints use `/api/*`**
* TanStack never exposes auth URLs publicly
* Mobile apps reuse the same API

---

## 9ï¸âƒ£ Absolute â€œdonâ€™tsâ€

âŒ Donâ€™t store user in localStorage
âŒ Donâ€™t decode tokens
âŒ Donâ€™t re-check auth in components
âŒ Donâ€™t skip backend permission checks

---

## ðŸ”‘ Final mantra

> **TanStack protects routes. Django authenticates users.
> They talk only through `/api/auth/me/` and sessions.**

If you want, I can compress this even further into a **10-line implementation recipe** or draw the **request flow diagram**.
